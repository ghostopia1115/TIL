# 문제 요약

줄 바꿈으로 구분되는 문자열 A와 B를 입력받아 A를 B로 바꾸기 위한 최소 편집 횟수를 구하는 문제. 
가할 수 있는 조작은 3가지가 존재. 
1. 문자 추가
1. 문자 삭제
1. 문자 교체

---

## 1차시

BOJ Random Defense - 실패
88분 소요
* 제한 시간 이후 풀이 방법을 찾아본 후 해결

가장 먼저 이 문제를 보았을 때 어떻게 접근하면 좋을지 갈피를 잡지 못했다. 
A라는 문자열에 가할 수 있는 많이 경우의 수의 조작 방법 중에서 어느 것을 택하는 것이 가장 효율적인지를 판단해야 한다고 생각했기 때문이다. 
그렇기에 '맞는 방향으로 가고 있다'라는 것을 알려줄 방향점이 필요하다고 생각했다. 
그래서 가장 먼저 취한 접근법이 LCS였다. 

---

### LCS 알고리즘

A와 B에 동일한 순서로 나타나는 수열 - 최장 공통 부분수열.
A와 B에 공통으로 나타나기 때문에 수정을 하지 않아도 되고, 이 공통 부분수열을 바탕으로 A에서 B로 바꾼다면 최소 편집횟수가 되지 않을까 생각했다. 
그래서 공통으로 나타나는 수열을 기준으로 그 사이에 있는 문자들을 A에 있는 것에서 B에 있는 것으로 변경을 하면 최소 편집횟수가 되지 않을까 하는 생각으로 접근했다. 
그래서 LCS를 어떻게 구하는지 알고리즘을 찾아보게 되었다. 

[LCS 알고리즘](/Algorithm/LCS.md)

그런데 이렇게 공통 부분수열을 찾는다고 해도 이것을 활용하는 것이 최단 편집 방법이라는 것을 보장할 수 없다는 것을 깨달았다. 
원래 LCS를 활용하려는 아이디어는 다음과 같았다. 

> LCS를 구해 문자열 A에서 '살릴 부분'과 '버릴 부분'을 구분을 하고, 
> '버릴 부분'에 대해서 '삭제' 조작을 할지 '교체' 조작을 할지 선택을 하여 문자열 A에서 문자열 B로 변환한다. 

그런데 생각을 하다 보니 LCS의 일부인데도 '살리지 않고' 교체를 해야 하는 반례를 발견했다. 

> **BCD**XYZ**H**
> **BCDH**KKK

이 경우 LCS인 BCDH를 기준으로 편집을 할 경우, A에 있는 XYZ를 삭제 (3번) 후 뒤에 KKK 삽입 (3번)
= 총 6번의 편집을 해야 한다
반대로 XYZH를 HKKK로 각각 교체를 할 경우 교체 4번으로 더 적은 횟수의 편집이 가능하다. 

때문에 다른 방식으로 접근해보기로 했다. 

---

### 브루트 포스 접근법

BOJ Random Defense로 풀고 있던 문제여서 제한 시간으로 인해 올바른 해결 방법이 알고도 브루트 포스 접근법을 사용해봤다. 
아이디어는 간단하다. 

> A와 B를 인자로 받아 편집 횟수를 반환하는 함수를 만든다. 
> A와 B에 모두 존재하는 문자 k를 1개 기준으로 잡는다. 
> k를 기준으로 앞과 뒤로 나누어 함수를 재귀 호출하여 편집 횟수를 더하여 저장한다. 
> 모든 k에 대해서 편집 횟수를 구하고, 그 중 최소값을 반환한다. 

어떻게든 '기준점'을 잡고 분할하여 풀어보려고 했다. 
실행 자체는 되고 구조상 문제는 없으나, 당연하게도 시간 초과가 나왔다. 
DP를 활용해야 하는 문제라는 것을 생각했을 때, 메모이제이션을 사용하지도 않은 것만 생각해도 통과될 수 없는 답이었다. 
시간이 오버가 날 것을 알고 있었기에 조금이라도 줄이기 위해 탐색을 하는 최대값을 줄이고 min을 제한하는 등 조치를 취했지만 어림도 없었다. 

[실패한 소스코드](./브루트포스.java)

---

### 올바른 접근방법

문제를 제대로 풀기 위해선 LCS 알고리즘을 조금 더 잘 알아야 했다. 
LCS 알고리즘에서 DP[i][j]에 저장하는 것이 **문자열 A의 (0~i)까지와 문자열 B의 (0~j)까지 LCS의 길이**이다. 
A의 i번째와 B의 j번째를 비교해서,
- 동일하다면 *(i-1, j-1)까지의 LCS의 길이*에 1을 더하고
- 다르다면 *(i-1, j)와 (i, j-1) LCS의 길이 중 최솟값*을 저장하는 것이다. 

왜냐하면 (i, j) 시점의 LCS의 길이는 그 이전까지의 LCS 길이에 현재 (i, j)의 문자에 따라 1이 늘어나거나 유지되기 떄문이다. 

이 문제를 풀기 위해선 LCS에서 DP에 저장하는 값을 조금 바꿔주면 된다. 
DP[i][j]에
> **문자열 A의 (0~i)를 문자열 B의 (0~j)로 바꾸는데 필요한 편집 횟수**

를 저장해 두는 것이다. 

이 편집 횟수는 **현재 i번째, j번째 문자**와 **[i-1][j-1], [i-1][j], [i][j-1]의 DP 값**을 참고하여 계산할 수 있다. 
- 두 문자가 동일한 경우 편집을 가할 필요가 없다. 따라서 현재 문자 바로 전의 값인 **[i-1][j-1]**의 값을 DP 배열에 저장한다. 
- 두 문자가 다른 경우 1회 수정이 필요하다. 
  삽입, 삭제, 교체 중 어떤 조작을 해야 하는지는 이후에 어떤 문자가 오는지에 따라 달라진다. 
  - 이 문자가 A와 B의 각각 마지막 문자였다면 교체를 해야 할 것이고, 
  - A에 문자가 더 있다면 삭제를, 
  - B에 문자가 더 있다면 삽입을 해야 할 것이다. 
  하지만 1회 조작이 필요하다는 사실은 변하지 않는다. 

따라서 LCS와 비슷한 방식으로 코드를 짜면 완성이다. 

[성공한 소스코드](./최소 편집.java)